package main

import (
	"fmt"
	"lession2/task4/eratosthenes"
	"lession2/task4/simple_numbers"
)

const (
	sieveSize          = 100
	simpleNumbersCount = 100
)

func main() {

	// сначала пойдем самым тупым путем. Работает корректно, но оооочень долгий уже на 100000 простых чисел
	// С делением каждого числа на все известные простые числа
	// bad way
	fmt.Println(simple_numbers.GetSimplesByCount(simpleNumbersCount))

	// Принцип решета Эратосфена в том, что мы вообще не проверяем на делимость ни одно число
	// он гораздо быстрее, потому что операции произовдятся безусловно и без попыток деления.
	// что мы делаем:
	// 2 3 4 5 6 7 8 9 10 11 12 13 14 15
	// первое число - 2. начиная с двойки идем с шагом в 2 и зачеркиваем числа. в данном случае я зануляю их
	// 2 3 0 5 0 7 0 9 0 11 0 13 0 15
	// следующее ненулевое число - простое. 3. идем с шагом 3 и зачеркиваем
	// 2 3 0 5 0 7 0 0 0 11 0 13 0 0 0
	// так же 5, 7 и так далее. получаем массив, где все сложные числа занулены и все, которые больше нуля - простые

	//erathosthenes sieve
	// получаем решето
	fmt.Println(eratosthenes.GetSieveByValue(sieveSize))

	// все известные на данный момент простые числа из решета
	// если границу решета увеличить, эта функция вернет новый слайс известных простых чисел
	fmt.Println(eratosthenes.GetAllKnownSimples())

	// получаем определенное количество простых чисел (если известного решета недостаточно - оно будет расширяться,
	// пока не станет содержать достаточное количество простых чисел)
	fmt.Println(eratosthenes.GetSimplesByCount(simpleNumbersCount))

	// получить все простые числа, находящиеся до числа n
	fmt.Println(eratosthenes.GetSimplesByValue(100))
}
